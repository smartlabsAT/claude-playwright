import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import readline from 'readline';

interface FixtureOptions {
  path?: string;
  type?: 'auth' | 'data' | 'api' | 'mixed';
  session?: string;
  pageObject?: string;
  interactive?: boolean;
  browserProfile?: string;
}

interface FixtureDefinition {
  name: string;
  type: 'page' | 'data' | 'auth' | 'api';
  description: string;
}

/**
 * Main function to scaffold a new Playwright fixture
 */
export async function scaffoldFixture(name: string, options: FixtureOptions = {}) {
  const className = toClassName(name);
  const fileName = toFileName(name);
  const targetDir = options.path || 'src/fixtures';
  const filePath = path.join(targetDir, `${fileName}.ts`);
  
  console.log(chalk.blue(`üîß Scaffolding fixture: ${className}...`));
  
  // Check if file exists
  if (await fs.pathExists(filePath)) {
    const overwrite = await askConfirmation(`${filePath} already exists. Overwrite?`);
    if (!overwrite) {
      console.log(chalk.yellow('‚ùå Fixture scaffolding cancelled'));
      return false;
    }
  }
  
  // Determine fixture type
  let fixtureType = options.type;
  if (!fixtureType) {
    fixtureType = detectFixtureType(fileName);
  }
  
  // Interactive mode for collecting fixture definitions
  let fixtures: FixtureDefinition[] = [];
  if (options.interactive !== false) {
    console.log(chalk.cyan('\nüõ†Ô∏è Let\'s define the fixture properties...'));
    fixtures = await collectFixtureDefinitions();
  }
  
  // Generate fixture content based on type
  const fixtureContent = generateFixtureContent({
    className,
    fileName,
    fixtureType,
    fixtures,
    options
  });
  
  // Ensure directory exists and write file
  await fs.ensureDir(targetDir);
  await fs.writeFile(filePath, fixtureContent);
  
  // Success feedback
  console.log(chalk.green('‚úÖ Fixture scaffolded successfully!'));
  console.log(chalk.gray(`üìÅ Location: ${filePath}`));
  console.log(chalk.gray(`üì¶ Import with: import { test, expect } from './${fileName}';`));
  
  // Usage examples
  console.log(chalk.blue('\nüí° Usage example:'));
  console.log(chalk.gray(`   test('my test', async ({ ${fileName}Page, ${fileName}Data }) => {`));
  console.log(chalk.gray(`     // Your test logic here`));
  console.log(chalk.gray(`   });`));
  
  return true;
}

/**
 * Detect fixture type based on name patterns
 */
function detectFixtureType(fileName: string): FixtureOptions['type'] {
  const lowerName = fileName.toLowerCase();
  
  if (lowerName.includes('auth') || lowerName.includes('login') || lowerName.includes('user')) {
    return 'auth';
  }
  
  if (lowerName.includes('api') || lowerName.includes('request') || lowerName.includes('endpoint')) {
    return 'api';
  }
  
  if (lowerName.includes('data') || lowerName.includes('mock') || lowerName.includes('stub')) {
    return 'data';
  }
  
  return 'mixed';
}

/**
 * Interactive collection of fixture definitions
 */
async function collectFixtureDefinitions(): Promise<FixtureDefinition[]> {
  const fixtures: FixtureDefinition[] = [];
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const askQuestion = (question: string): Promise<string> => {
    return new Promise((resolve) => {
      rl.question(question, resolve);
    });
  };
  
  try {
    while (true) {
      console.log(chalk.cyan('\n‚öôÔ∏è Add a fixture (or press Enter to finish):'));
      const fixtureName = await askQuestion('Fixture name (e.g., authenticatedPage, testData): ');
      
      if (!fixtureName.trim()) break;
      
      const type = await askQuestion('Type (page/data/auth/api) [data]: ') || 'data';
      const description = await askQuestion('Description [optional]: ');
      
      fixtures.push({
        name: toCamelCase(fixtureName),
        type: type as FixtureDefinition['type'],
        description: description || `${fixtureName} fixture`
      });
      
      console.log(chalk.green(`‚úì Added fixture: ${fixtureName}`));
    }
  } finally {
    rl.close();
  }
  
  return fixtures;
}

/**
 * Generate the complete fixture content
 */
function generateFixtureContent(config: {
  className: string;
  fileName: string;
  fixtureType: FixtureOptions['type'];
  fixtures: FixtureDefinition[];
  options: FixtureOptions;
}): string {
  const { className, fileName, fixtureType, fixtures, options } = config;
  
  const imports = generateImports(fixtureType, options);
  const interfaces = generateInterfaces(className, fixtures);
  const fixtureImplementations = generateFixtureImplementations(fixtures, options);
  
  return `${imports}

/**
 * ${className} Fixtures
 * Generated by claude-playwright scaffold
 */
${interfaces}

export const test = base.extend<${className}>({
${fixtureImplementations}
});

export { expect } from '@playwright/test';

${generateHelperFunctions(fixtureType, options)}
`;
}

/**
 * Generate imports based on fixture type
 */
function generateImports(fixtureType: FixtureOptions['type'], options: FixtureOptions): string {
  let imports = `import { test as base, expect } from '@playwright/test';`;
  
  // Add specific imports based on type
  if (fixtureType === 'auth' || options.session) {
    imports += `\nimport { SessionManager } from '../core/session-manager';`;
    imports += `\nimport fs from 'fs-extra';`;
    imports += `\nimport path from 'path';`;
  }

  if (options.browserProfile) {
    imports += `\nimport { BrowserProfileManager } from '../core/browser-profile';`;
  }
  
  if (fixtureType === 'api') {
    imports += `\nimport { APIRequestContext } from '@playwright/test';`;
  }
  
  if (options.pageObject) {
    imports += `\nimport { ${options.pageObject} } from '../pages/${options.pageObject}';`;
  } else {
    imports += `\nimport { BasePage } from '../pages/base/BasePage';`;
  }
  
  return imports;
}

/**
 * Generate TypeScript interfaces for fixtures
 */
function generateInterfaces(className: string, fixtures: FixtureDefinition[]): string {
  if (fixtures.length === 0) {
    // Generate default interface based on className
    const baseName = className.replace('Fixtures', '');
    return `export interface ${className} {
  ${toCamelCase(baseName)}Page: BasePage;
  ${toCamelCase(baseName)}Data: any;
}`;
  }
  
  const properties = fixtures.map(fixture => {
    const type = getFixtureType(fixture.type);
    return `  ${fixture.name}: ${type};`;
  }).join('\n');
  
  return `export interface ${className} {
${properties}
}`;
}

/**
 * Generate fixture implementations
 */
function generateFixtureImplementations(fixtures: FixtureDefinition[], options: FixtureOptions): string {
  if (fixtures.length === 0) {
    // Generate default implementations
    return generateDefaultFixtures(options);
  }
  
  return fixtures.map(fixture => generateSingleFixture(fixture, options)).join(',\\n\\n');
}

/**
 * Generate a single fixture implementation
 */
function generateSingleFixture(fixture: FixtureDefinition, options: FixtureOptions): string {
  switch (fixture.type) {
    case 'page':
      return `  ${fixture.name}: async ({ page }, use) => {
    const ${fixture.name} = new ${options.pageObject || 'BasePage'}(page);
    
    // Setup page if needed
    await ${fixture.name}.goto();
    await ${fixture.name}.waitForLoad();
    
    await use(${fixture.name});
  }`;
    
    case 'auth':
      return `  ${fixture.name}: async ({ page }, use) => {
    const sessionManager = new SessionManager();
    
    // Load session if available
    const session = await sessionManager.loadSession('${options.session || 'default'}');
    if (session) {
      await page.context().addCookies(session.cookies);
      
      // Apply localStorage data
      if (session.origins) {
        for (const origin of session.origins) {
          await page.addInitScript((data) => {
            for (const [key, value] of Object.entries(data.localStorage)) {
              window.localStorage.setItem(key, value as string);
            }
          }, { localStorage: origin.localStorage });
        }
      }
    }
    
    const authPage = new ${options.pageObject || 'BasePage'}(page);
    await use(authPage);
  }`;
    
    case 'data':
      return `  ${fixture.name}: async ({}, use) => {
    const testData = {
      // Add your test data here
      ${generateTestDataProperties()}
    };
    
    await use(testData);
  }`;
    
    case 'api':
      return `  ${fixture.name}: async ({ request }, use) => {
    // Setup API client with base configuration
    const apiClient = {
      baseURL: process.env.API_BASE_URL || 'http://localhost:3000/api',
      
      async get(endpoint: string) {
        return await request.get(\`\${this.baseURL}\${endpoint}\`);
      },
      
      async post(endpoint: string, data: any) {
        return await request.post(\`\${this.baseURL}\${endpoint}\`, { data });
      },
      
      async put(endpoint: string, data: any) {
        return await request.put(\`\${this.baseURL}\${endpoint}\`, { data });
      },
      
      async delete(endpoint: string) {
        return await request.delete(\`\${this.baseURL}\${endpoint}\`);
      }
    };
    
    await use(apiClient);
  }`;
    
    default:
      return `  ${fixture.name}: async ({}, use) => {
    // Custom fixture implementation
    const fixture = {
      // Add your fixture logic here
    };
    
    await use(fixture);
  }`;
  }
}

/**
 * Generate default fixtures when none specified
 */
function generateDefaultFixtures(options: FixtureOptions): string {
  const pageObjectClass = options.pageObject || 'BasePage';
  
  let fixtures = `  ${toCamelCase(pageObjectClass.replace('Page', ''))}Page: async ({ page }, use) => {
    const pageObject = new ${pageObjectClass}(page);
    await pageObject.goto();
    await pageObject.waitForLoad();
    await use(pageObject);
  }`;
  
  fixtures += `,\\n\\n  ${toCamelCase(pageObjectClass.replace('Page', ''))}Data: async ({}, use) => {
    const testData = {
      ${generateTestDataProperties()}
    };
    
    await use(testData);
  }`;
  
  return fixtures;
}

/**
 * Generate test data properties
 */
function generateTestDataProperties(): string {
  return `sampleText: 'Test Data',
      sampleNumber: 42,
      sampleBoolean: true,
      sampleArray: ['item1', 'item2', 'item3'],
      sampleObject: {
        key1: 'value1',
        key2: 'value2'
      },
      // Add more test data as needed`;
}

/**
 * Generate helper functions based on fixture type
 */
function generateHelperFunctions(fixtureType: FixtureOptions['type'], options: FixtureOptions): string {
  let helpers = '';
  
  if (fixtureType === 'auth' || options.session) {
    helpers += `
/**
 * Helper function to save authentication state
 */
export async function saveAuthState(page: any, filename = 'user.json'): Promise<string> {
  const authStateDir = path.join(process.cwd(), 'playwright-sessions');
  await fs.ensureDir(authStateDir);
  
  const storageState = await page.context().storageState();
  const authStatePath = path.join(authStateDir, filename);
  
  await fs.writeJSON(authStatePath, storageState, { spaces: 2 });
  console.log('Auth state saved to:', authStatePath);
  
  return authStatePath;
}

/**
 * Helper function to load authentication state
 */
export async function loadAuthState(filename = 'user.json'): Promise<any> {
  const authStatePath = path.join(process.cwd(), 'playwright-sessions', filename);
  
  if (await fs.pathExists(authStatePath)) {
    return await fs.readJSON(authStatePath);
  }
  
  return null;
}`;
  }
  
  if (fixtureType === 'data') {
    helpers += `
/**
 * Helper function to generate random test data
 */
export function generateTestData(type: 'user' | 'product' | 'order' | 'custom' = 'custom') {
  const timestamp = Date.now();
  
  const generators = {
    user: () => ({
      id: timestamp,
      email: \`test\${timestamp}@example.com\`,
      username: \`user\${timestamp}\`,
      firstName: 'Test',
      lastName: 'User'
    }),
    
    product: () => ({
      id: timestamp,
      name: \`Test Product \${timestamp}\`,
      price: Math.floor(Math.random() * 1000) + 10,
      category: 'Test Category',
      inStock: true
    }),
    
    order: () => ({
      id: timestamp,
      userId: timestamp - 1,
      total: Math.floor(Math.random() * 500) + 50,
      status: 'pending',
      items: []
    }),
    
    custom: () => ({
      id: timestamp,
      value: \`test-value-\${timestamp}\`,
      timestamp
    })
  };
  
  return generators[type]();
}`;
  }
  
  return helpers;
}

/**
 * Get TypeScript type for fixture
 */
function getFixtureType(fixtureType: FixtureDefinition['type']): string {
  switch (fixtureType) {
    case 'page':
      return 'BasePage';
    case 'auth':
      return 'BasePage';
    case 'data':
      return 'any';
    case 'api':
      return 'any';
    default:
      return 'any';
  }
}

/**
 * Ask for user confirmation
 */
async function askConfirmation(question: string): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  return new Promise((resolve) => {
    rl.question(`${question} (y/N): `, (answer) => {
      rl.close();
      resolve(answer.toLowerCase().startsWith('y'));
    });
  });
}

/**
 * Utility functions
 */
function toClassName(name: string): string {
  const clean = name.replace(/[^a-zA-Z0-9]/g, '');
  const className = clean.charAt(0).toUpperCase() + clean.slice(1);
  return className.endsWith('Fixtures') ? className : className + 'Fixtures';
}

function toFileName(name: string): string {
  return name
    .toLowerCase()
    .replace(/fixtures?$/i, '')
    .replace(/[^a-z0-9]/gi, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

function toCamelCase(str: string): string {
  const clean = str.replace(/Fixtures?$/i, '');
  return clean.charAt(0).toLowerCase() + 
         clean.slice(1).replace(/[-_\\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');
}