import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import readline from 'readline';

interface PageOptions {
  path?: string;
  selectors?: string[];
  actions?: string[];
  url?: string;
  interactive?: boolean;
  browserProfile?: string;
}

interface ElementDefinition {
  name: string;
  selector: string;
  type: 'locator' | 'action' | 'assertion';
}

/**
 * Main function to scaffold a new Page Object
 */
export async function scaffoldPage(name: string, options: PageOptions = {}) {
  const className = toClassName(name);
  const fileName = toFileName(name);
  const targetDir = options.path || 'src/pages';
  const filePath = path.join(targetDir, `${className}.ts`);
  
  console.log(chalk.blue(`üèóÔ∏è Scaffolding ${className}...`));
  
  // Check if file exists
  if (await fs.pathExists(filePath)) {
    const overwrite = await askConfirmation(`${filePath} already exists. Overwrite?`);
    if (!overwrite) {
      console.log(chalk.yellow('‚ùå Scaffolding cancelled'));
      return false;
    }
  }
  
  // Interactive mode for collecting page elements
  let elements: ElementDefinition[] = [];
  if (options.interactive !== false) {
    console.log(chalk.cyan('\nüìù Let\'s define the page elements...'));
    elements = await collectPageElements();
  }
  
  // Generate page content
  const pageContent = generatePageContent(className, fileName, elements, options.url);
  
  // Ensure directory exists and write file
  await fs.ensureDir(targetDir);
  await fs.writeFile(filePath, pageContent);
  
  // Success feedback
  console.log(chalk.green('‚úÖ Page scaffolded successfully!'));
  console.log(chalk.gray(`üìÅ Location: ${filePath}`));
  console.log(chalk.gray(`üì¶ Import with: import { ${className} } from './${className}';`));
  
  // Generate corresponding test file suggestion
  const testPath = filePath.replace('/pages/', '/tests/').replace('.ts', '.spec.ts');
  console.log(chalk.blue(`\nüí° Suggestion: Generate test with:`));
  console.log(chalk.gray(`   claude-playwright scaffold test ${className} --path ${path.dirname(testPath)}`));
  
  return true;
}

/**
 * Interactive collection of page elements
 */
async function collectPageElements(): Promise<ElementDefinition[]> {
  const elements: ElementDefinition[] = [];
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const askQuestion = (question: string): Promise<string> => {
    return new Promise((resolve) => {
      rl.question(question, resolve);
    });
  };
  
  try {
    while (true) {
      console.log(chalk.cyan('\nüîç Add a page element (or press Enter to finish):'));
      const elementName = await askQuestion('Element name (e.g., loginButton, emailField): ');
      
      if (!elementName.trim()) break;
      
      const selector = await askQuestion('CSS selector (e.g., #login-btn, [data-testid="email"]): ');
      if (!selector.trim()) continue;
      
      const type = await askQuestion('Type (locator/action/assertion) [locator]: ') || 'locator';
      
      elements.push({
        name: toCamelCase(elementName),
        selector,
        type: type as ElementDefinition['type']
      });
      
      console.log(chalk.green(`‚úì Added ${elementName} -> ${selector}`));
    }
  } finally {
    rl.close();
  }
  
  return elements;
}

/**
 * Generate the complete page class content
 */
function generatePageContent(
  className: string, 
  fileName: string, 
  elements: ElementDefinition[], 
  url?: string,
  browserProfile?: string
): string {
  const locators = elements.filter(e => e.type === 'locator' || !e.type);
  const actionElements = elements.filter(e => e.type === 'action');
  const assertionElements = elements.filter(e => e.type === 'assertion');
  
  return `import { Page, expect, Locator } from '@playwright/test';
import { BasePage } from '../pages/base/BasePage';

/**
 * ${className} - Page Object Model
 * Generated by claude-playwright scaffold
 */
export class ${className} extends BasePage {
  constructor(page: Page) {
    super(page);
  }

  // Page URL
  private readonly pageUrl = '${url || `/${fileName}`}';${browserProfile ? `\n  // Browser Profile\n  private readonly browserProfile = '${browserProfile}';` : ''}
  
  // Locators${generateLocators(locators)}

  // Navigation
  async goto(): Promise<void> {
    await this.navigateTo(this.pageUrl);
    await this.waitForNetworkIdle();
  }
  
  async waitForLoad(): Promise<void> {
    ${locators.length > 0 ? `await this.waitForElement('${locators[0].selector}');` : 'await this.waitForNetworkIdle();'}
  }

  // Actions${generateActions(actionElements, locators)}

  // Assertions${generateAssertions(assertionElements, locators)}
  
  // Helper Methods
  async isLoaded(): Promise<boolean> {
    ${locators.length > 0 ? `return await this.isElementVisible('${locators[0].selector}');` : 'return true;'}
  }
}
`;
}

/**
 * Generate locator definitions
 */
function generateLocators(locators: ElementDefinition[]): string {
  if (locators.length === 0) {
    return `
  private readonly mainContent = '[data-testid="main-content"], main, .content';`;
  }
  
  return locators.map(el => 
    `\n  private readonly ${el.name} = '${el.selector}';`
  ).join('');
}

/**
 * Generate action methods
 */
function generateActions(actionElements: ElementDefinition[], allElements: ElementDefinition[]): string {
  const actions = actionElements.length > 0 ? actionElements : allElements.slice(0, 2);
  
  if (actions.length === 0) {
    return `
  async clickMainContent(): Promise<void> {
    await this.clickAndWait(this.mainContent);
  }`;
  }
  
  return actions.map(el => {
    const methodName = el.name.startsWith('click') ? el.name : `click${capitalize(el.name)}`;
    return `\n  async ${methodName}(): Promise<void> {
    await this.clickAndWait(this.${el.name});
  }`;
  }).join('');
}

/**
 * Generate assertion methods
 */
function generateAssertions(assertionElements: ElementDefinition[], allElements: ElementDefinition[]): string {
  const assertions = assertionElements.length > 0 ? assertionElements : allElements.slice(0, 2);
  
  if (assertions.length === 0) {
    return `
  async expectPageLoaded(): Promise<void> {
    await this.expectElementVisible(this.mainContent);
  }`;
  }
  
  return assertions.map(el => {
    const methodName = el.name.startsWith('expect') ? el.name : `expect${capitalize(el.name)}Visible`;
    return `\n  async ${methodName}(): Promise<void> {
    await this.expectElementVisible(this.${el.name});
  }`;
  }).join('');
}

/**
 * Ask for user confirmation
 */
async function askConfirmation(question: string): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  return new Promise((resolve) => {
    rl.question(`${question} (y/N): `, (answer) => {
      rl.close();
      resolve(answer.toLowerCase().startsWith('y'));
    });
  });
}

/**
 * Utility functions
 */
function toClassName(name: string): string {
  const clean = name.replace(/[^a-zA-Z0-9]/g, '');
  const className = clean.charAt(0).toUpperCase() + clean.slice(1);
  return className.endsWith('Page') ? className : className + 'Page';
}

function toFileName(name: string): string {
  return name.toLowerCase().replace(/page$/i, '').replace(/[^a-z0-9]/gi, '-');
}

function toCamelCase(str: string): string {
  return str.replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '');
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}